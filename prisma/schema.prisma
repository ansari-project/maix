generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Organization {
  id           String               @id @default(cuid())
  name         String
  slug         String               @unique
  mission      String?
  description  String?
  url          String?
  aiEngagement String?
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt
  members      OrganizationMember[]
  products     Product[]
  projects     Project[]
  invitations  Invitation[]
  events       MaixEvent[]          @relation("OrganizationEvents")

  @@map("organizations")
}

model OrganizationMember {
  id             String       @id @default(cuid())
  role           OrgRole
  unifiedRole    UnifiedRole? // For role unification migration (separate from following)
  joinedAt       DateTime     @default(now())
  organizationId String
  userId         String
  invitationId   String?
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  invitation     Invitation?  @relation(fields: [invitationId], references: [id])

  @@unique([organizationId, userId])
  @@index([userId])
  @@index([organizationId])
  @@index([role])
  @@map("organization_members")
}

model ProductMember {
  id           String      @id @default(cuid())
  role         UnifiedRole @default(MEMBER)
  joinedAt     DateTime    @default(now())
  productId    String
  userId       String
  invitationId String?
  product      Product     @relation(fields: [productId], references: [id], onDelete: Cascade)  
  user         User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  invitation   Invitation? @relation(fields: [invitationId], references: [id])

  @@unique([productId, userId])
  @@index([userId])
  @@index([role])
  @@map("product_members")
}

model ProjectMember {
  id           String      @id @default(cuid())
  role         UnifiedRole @default(MEMBER)
  joinedAt     DateTime    @default(now())
  projectId    String
  userId       String
  invitationId String?
  project      Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user         User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  invitation   Invitation? @relation(fields: [invitationId], references: [id])

  @@unique([projectId, userId])
  @@index([userId])
  @@index([role])
  @@map("project_members")
}

model User {
  id                      String                  @id @default(cuid())
  email                   String                  @unique
  username                String                  @unique
  name                    String?
  image                   String?
  password                String?
  specialty               Specialty?
  experienceLevel         ExperienceLevel?
  bio                     String?
  linkedinUrl             String?
  githubUrl               String?
  portfolioUrl            String?
  skills                  String[]
  availability            String?
  timezone                String?
  isActive                Boolean                 @default(true)
  createdAt               DateTime                @default(now())
  updatedAt               DateTime                @updatedAt
  lastDigestSentAt        DateTime?
  applications            Application[]
  comments                Comment[]
  messages                Message[]
  monitors                Monitor[]
  notificationPreference  NotificationPreference?
  notifications           Notification[]
  organizationMemberships OrganizationMember[]
  personalAccessTokens    PersonalAccessToken[]
  posts                   Post[]
  productMemberships      ProductMember[]
  products                Product[]
  projectMemberships      ProjectMember[]
  projects                Project[]
  todosAssigned           Todo[]                  @relation("TodosAssigned")
  todosCreated            Todo[]                  @relation("TodosCreated")
  invitationsSent         Invitation[]            @relation("InvitationsSent")
  eventsCreated           MaixEvent[]             @relation("EventsCreated")
  registrations           Registration[]
  eventConversations      EventConversation[]
  aiConversations         AIConversation[]
  userPreferences         UserPreferences?
  following               Following[]      // Pure notification subscriptions

  @@index([skills], type: Gin)
  @@map("users")
}

model Project {
  id                   String          @id @default(cuid())
  name                 String
  goal                 String?         // Nullable for personal projects
  description          String
  contactEmail         String?         // Nullable for personal projects
  helpType             HelpType?       // Nullable for personal projects
  status               ProjectStatus   @default(AWAITING_VOLUNTEERS)
  targetCompletionDate DateTime?
  isActive             Boolean         @default(true)
  isPersonal           Boolean         @default(false) // Personal vs Organization project
  personalCategory     String?         // Free-form category for personal projects
  createdAt            DateTime        @default(now())
  updatedAt            DateTime        @updatedAt
  ownerId              String?
  productId            String?
  organizationId       String?
  visibility           Visibility      @default(PUBLIC)
  applications         Application[]
  notifications        Notification[]
  discussionPost       Post?           @relation("ProjectDiscussionThread")
  updates              Post[]          @relation("ProjectUpdates")
  members              ProjectMember[]
  organization         Organization?   @relation(fields: [organizationId], references: [id], onDelete: Restrict)
  owner                User?           @relation(fields: [ownerId], references: [id])
  product              Product?        @relation(fields: [productId], references: [id])
  todos                Todo[]
  invitations          Invitation[]

  @@index([isActive, createdAt])
  @@index([status])
  @@index([isPersonal, ownerId]) // For personal projects query
  @@map("projects")
}

model Product {
  id             String          @id @default(cuid())
  name           String
  description    String
  url            String?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  ownerId        String?
  organizationId String?
  visibility     Visibility      @default(PUBLIC)
  discussionPost Post?           @relation("ProductDiscussionThread")
  updates        Post[]          @relation("ProductUpdates")
  members        ProductMember[]
  organization   Organization?   @relation(fields: [organizationId], references: [id], onDelete: Restrict)
  owner          User?           @relation(fields: [ownerId], references: [id], onDelete: Restrict)
  projects       Project[]
  invitations    Invitation[]

  @@map("products")
}

model Application {
  id          String            @id @default(cuid())
  message     String
  status      ApplicationStatus @default(PENDING)
  appliedAt   DateTime          @default(now())
  respondedAt DateTime?
  userId      String
  projectId   String
  project     Project           @relation(fields: [projectId], references: [id])
  user        User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, projectId])
  @@index([userId])
  @@index([projectId])
  @@map("applications")
}

model Message {
  id          String   @id @default(cuid())
  content     String
  isRead      Boolean  @default(false)
  sentAt      DateTime @default(now())
  senderId    String
  recipientId String
  sender      User     @relation(fields: [senderId], references: [id])

  @@map("messages")
}

model PersonalAccessToken {
  id                String           @id @default(cuid())
  userId            String
  tokenHash         String           @unique
  name              String
  scopes            String[]
  isSystemGenerated Boolean          @default(false)
  createdAt         DateTime         @default(now())
  lastUsedAt        DateTime?
  expiresAt         DateTime?
  encryptedToken    String?          @db.Text // Encrypted token for AI Assistant retrieval
  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  userPreferences   UserPreferences?

  @@index([userId])
  @@map("personal_access_tokens")
}

/// Structured content posts for questions, answers, and updates.
/// Implements the "Discussion Anchor Pattern" where PROJECT_DISCUSSION and PRODUCT_DISCUSSION
/// posts serve as anchors for comments on projects/products.
model Post {
  id                        String     @id @default(cuid())
  createdAt                 DateTime   @default(now())
  updatedAt                 DateTime   @updatedAt
  type                      PostType
  content                   String
  visibility                Visibility @default(PUBLIC)
  authorId                  String?
  projectId                 String?
  projectDiscussionThreadId String?   @unique
  productId                 String?
  productDiscussionThreadId String?   @unique
  maixEventId               String?
  parentId                  String?
  isResolved                Boolean   @default(false)
  bestAnswerId              String?   @unique
  todoId                    String?
  comments                  Comment[]
  author                    User?     @relation(fields: [authorId], references: [id])
  bestAnswer                Post?     @relation("BestAnswer", fields: [bestAnswerId], references: [id], onDelete: Restrict)
  questionForBestAnswer     Post?     @relation("BestAnswer")
  parent                    Post?     @relation("PostReplies", fields: [parentId], references: [id], onDelete: Restrict)
  replies                   Post[]    @relation("PostReplies")
  productDiscussionThread   Product?  @relation("ProductDiscussionThread", fields: [productDiscussionThreadId], references: [id], onDelete: Cascade)
  product                   Product?  @relation("ProductUpdates", fields: [productId], references: [id], onDelete: Cascade)
  projectDiscussionThread   Project?  @relation("ProjectDiscussionThread", fields: [projectDiscussionThreadId], references: [id], onDelete: Cascade)
  project                   Project?  @relation("ProjectUpdates", fields: [projectId], references: [id], onDelete: Cascade)
  maixEvent                 MaixEvent? @relation("MaixEventPosts", fields: [maixEventId], references: [id], onDelete: Cascade)
  todo                      Todo?     @relation("TodoPosts", fields: [todoId], references: [id])

  @@index([authorId])
  @@index([projectId])
  @@index([productId])
  @@index([parentId])
  @@index([projectDiscussionThreadId])
  @@index([productDiscussionThreadId])
  @@index([bestAnswerId])
  @@index([type, createdAt])
  @@index([todoId])
  @@index([maixEventId])
  @@map("posts")
}

model Comment {
  id        String    @id @default(cuid())
  content   String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  authorId  String?
  postId    String?
  todoId    String?
  parentId  String?
  author    User?     @relation(fields: [authorId], references: [id])
  parent    Comment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Restrict)
  replies   Comment[] @relation("CommentReplies")
  post      Post?     @relation(fields: [postId], references: [id], onDelete: Cascade)
  todo      Todo?     @relation(fields: [todoId], references: [id], onDelete: Cascade)

  @@index([postId])
  @@index([todoId])
  @@index([authorId])
  @@index([parentId])
  @@map("comments")
}

model Notification {
  id         String           @id @default(cuid())
  type       NotificationType
  title      String
  message    String
  entityType String
  entityId   String
  read       Boolean          @default(false)
  readAt     DateTime?
  createdAt  DateTime         @default(now())
  userId     String
  projectId  String?
  project    Project?         @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user       User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, read, createdAt])
  @@index([userId, createdAt])
  @@map("notifications")
}

model NotificationPreference {
  id           String   @id @default(cuid())
  userId       String   @unique
  emailEnabled Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notification_preferences")
}

model Monitor {
  id             String        @id @default(cuid())
  userId         String
  publicFigureId String
  topicId        String
  isActive       Boolean       @default(true)
  emailFrequency String        @default("daily")
  lastSearchedAt DateTime?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  emailReports   EmailReport[]
  publicFigure   PublicFigure  @relation(fields: [publicFigureId], references: [id])
  topic          Topic         @relation(fields: [topicId], references: [id])
  user           User          @relation(fields: [userId], references: [id])

  @@unique([userId, publicFigureId, topicId])
  @@index([userId])
  @@index([isActive, emailFrequency])
  @@map("monitors")
}

model PublicFigure {
  id        String    @id @default(cuid())
  name      String
  title     String?
  imageUrl  String?
  aliases   String[]
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  events    Event[]
  monitors  Monitor[]

  @@index([name])
  @@map("public_figures")
}

model Topic {
  id        String    @id @default(cuid())
  name      String
  keywords  String[]
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  events    Event[]
  monitors  Monitor[]

  @@index([name])
  @@map("topics")
}

model Event {
  id                String       @id @default(cuid())
  publicFigureId    String
  topicId           String
  title             String
  summary           String
  eventDate         DateTime
  eventType         String
  sentiment         String?
  stance            String?
  deduplicationHash String       @unique
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  articles          Article[]
  publicFigure      PublicFigure @relation(fields: [publicFigureId], references: [id])
  topic             Topic        @relation(fields: [topicId], references: [id])

  @@index([publicFigureId, topicId, eventDate])
  @@map("events")
}

model Article {
  id              String   @id @default(cuid())
  eventId         String
  headline        String
  sourceUrl       String   @unique
  sourceType      String
  sourcePublisher String
  publishedAt     DateTime
  fullText        String?
  keyQuotes       Json?
  contentHash     String   @unique
  createdAt       DateTime @default(now())
  event           Event    @relation(fields: [eventId], references: [id])

  @@index([eventId])
  @@index([sourceUrl])
  @@index([contentHash])
  @@map("articles")
}

model EmailReport {
  id         String   @id @default(cuid())
  monitorId  String
  eventIds   String[]
  eventCount Int
  sentAt     DateTime @default(now())
  status     String   @default("sent")
  monitor    Monitor  @relation(fields: [monitorId], references: [id])

  @@index([monitorId, sentAt])
  @@map("email_reports")
}

model Todo {
  id          String     @id @default(cuid())
  title       String     @db.VarChar(255)
  description String?
  status      TodoStatus @default(NOT_STARTED)
  startDate   DateTime?  // When to start working on this task
  dueDate     DateTime?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  projectId   String?
  eventId     String?
  creatorId   String
  assigneeId  String?
  posts       Post[]     @relation("TodoPosts")
  comments    Comment[]
  assignee    User?      @relation("TodosAssigned", fields: [assigneeId], references: [id])
  creator     User       @relation("TodosCreated", fields: [creatorId], references: [id])
  project     Project?   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  event       MaixEvent? @relation("EventTodos", fields: [eventId], references: [id], onDelete: Cascade)

  @@index([projectId, status])
  @@index([eventId, status])
  @@index([assigneeId, status])
  @@map("todos")
}

model Invitation {
  id             String           @id @default(cuid())
  hashedToken    String           @unique @db.VarChar(64) // SHA-256 hash of invitation token
  email          String           @db.VarChar(255)
  status         InvitationStatus @default(PENDING)
  role           UnifiedRole      @default(MEMBER)
  message        String?          @db.Text // Personal message from inviter
  expiresAt      DateTime
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  acceptedAt     DateTime?
  
  // Inviter information
  inviterId      String
  inviter        User             @relation("InvitationsSent", fields: [inviterId], references: [id])
  
  // Entity being invited to (one of these will be set)
  organizationId String?
  productId      String?
  projectId      String?
  
  // Entity relations
  organization   Organization?    @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  product        Product?         @relation(fields: [productId], references: [id], onDelete: Cascade)
  project        Project?         @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  // Membership relations (created when invitation is accepted)
  organizationMember OrganizationMember[]
  productMember      ProductMember[]
  projectMember      ProjectMember[]

  @@index([hashedToken]) // Fast hashed token lookup
  @@index([email, status]) // Find pending invitations for email
  @@index([organizationId, status]) // Org invitation management
  @@index([productId, status]) // Product invitation management  
  @@index([projectId, status]) // Project invitation management
  @@index([inviterId]) // Inviter's sent invitations
  @@index([expiresAt, status]) // Cleanup expired invitations
  @@map("invitations")
}

// Pure notification subscription system - grants ZERO permissions
model Following {
  id                   String         @id @default(cuid())
  userId               String
  followableId         String
  followableType       FollowableType
  followedAt           DateTime       @default(now())
  notificationsEnabled Boolean        @default(true)
  
  user                 User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, followableId, followableType])
  @@index([followableId, followableType]) // For getFollowers() queries
  @@index([userId, followableType])       // For getUserFollowing() queries
  @@index([followedAt])
  @@map("following")
}

enum FollowableType {
  ORGANIZATION
  PROJECT
  PRODUCT
}

enum InvitationStatus {
  PENDING   // Invitation sent, awaiting response
  ACCEPTED  // Invitation accepted, membership created
  DECLINED  // Invitation declined by recipient
  EXPIRED   // Invitation expired
  CANCELLED // Invitation cancelled by inviter
}

enum Visibility {
  PUBLIC
  PRIVATE
  DRAFT
}

enum UnifiedRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

enum OrgRole {
  OWNER
  MEMBER
}

enum Specialty {
  AI
  FULL_STACK
  PROGRAM_MANAGER
}

enum ExperienceLevel {
  HOBBYIST
  INTERN
  NEW_GRAD
  SENIOR
}

enum HelpType {
  ADVICE
  PROTOTYPE
  FEATURE
  MVP
  FULL_PRODUCT
}

enum ProjectStatus {
  AWAITING_VOLUNTEERS
  PLANNING
  IN_PROGRESS
  ON_HOLD
  COMPLETED
  CANCELLED
}

enum ApplicationStatus {
  PENDING
  ACCEPTED
  REJECTED
  WITHDRAWN
}

enum PostType {
  QUESTION
  ANSWER
  PROJECT_UPDATE
  PRODUCT_UPDATE
  PROJECT_DISCUSSION
  PRODUCT_DISCUSSION
  EVENT_UPDATE
  EVENT_DISCUSSION
}

enum NotificationType {
  APPLICATION_NEW
  APPLICATION_ACCEPTED
  APPLICATION_REJECTED
  ANSWER_NEW
  NEW_QUESTION
  NEW_PROJECT
}

enum TodoStatus {
  NOT_STARTED
  IN_PROGRESS
  WAITING_FOR
  COMPLETED
}

// New Event models
model MaixEvent {
  id              String             @id @default(cuid())
  organizationId  String
  organization    Organization       @relation("OrganizationEvents", fields: [organizationId], references: [id])
  name            String
  description     String             @db.Text
  date            DateTime
  venueJson       Json?
  capacity        Int?
  status          MaixEventStatus    @default(DRAFT)
  isPublic        Boolean            @default(true)
  createdBy       String
  creator         User               @relation("EventsCreated", fields: [createdBy], references: [id])
  todos           Todo[]             @relation("EventTodos")
  posts           Post[]             @relation("MaixEventPosts")
  registrations   Registration[]
  conversations   EventConversation[]
  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt

  @@index([organizationId, status])
  @@map("maix_events")
}

model Registration {
  id        String             @id @default(cuid())
  eventId   String
  event     MaixEvent          @relation(fields: [eventId], references: [id], onDelete: Cascade)
  userId    String?
  user      User?              @relation(fields: [userId], references: [id])
  email     String
  name      String
  status    RegistrationStatus @default(PENDING)
  metadata  Json?
  createdAt DateTime           @default(now())

  @@unique([eventId, email])
  @@index([eventId, status])
  @@map("registrations")
}

model EventConversation {
  id        String   @id @default(cuid())
  eventId   String
  event     MaixEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  messages  Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([eventId, userId])
  @@map("event_conversations")
}

model AIConversation {
  id          String   @id @default(cuid())
  userId      String
  title       String?  // Auto-generated from first message
  messages    Json     // Array of messages with roles
  metadata    Json?    // Tool usage stats, etc.
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  lastActiveAt DateTime @default(now())
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, lastActiveAt])
  @@map("ai_conversations")
}

model UserPreferences {
  id                String               @id @default(cuid())
  userId            String               @unique
  user              User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  eventManagerPatId String?              @unique
  eventManagerPat   PersonalAccessToken? @relation(fields: [eventManagerPatId], references: [id])
  createdAt         DateTime             @default(now())
  updatedAt         DateTime             @updatedAt

  @@map("user_preferences")
}

enum MaixEventStatus {
  DRAFT
  PLANNING
  PUBLISHED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum RegistrationStatus {
  PENDING
  CONFIRMED
  CANCELLED
  WAITLISTED
}
